{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst column_1 = require(\"./column\");\n\nconst Token_1 = require(\"./Token\");\n\nconst {\n  isTokenRowDelimiter,\n  isTokenCarriageReturn,\n  isTokenDelimiter\n} = Token_1.Token;\n\nclass RowParser {\n  constructor(parserOptions) {\n    this.parserOptions = parserOptions;\n    this.columnParser = new column_1.ColumnParser(parserOptions);\n  }\n\n  parse(scanner) {\n    const {\n      parserOptions\n    } = this;\n    const {\n      hasMoreData\n    } = scanner;\n    const currentScanner = scanner;\n    const columns = [];\n    let currentToken = this.getStartToken(currentScanner, columns);\n\n    while (currentToken) {\n      if (isTokenRowDelimiter(currentToken)) {\n        currentScanner.advancePastToken(currentToken); // if ends with CR and there is more data, keep unparsed due to possible\n        // coming LF in CRLF\n\n        if (!currentScanner.hasMoreCharacters && isTokenCarriageReturn(currentToken, parserOptions) && hasMoreData) {\n          return null;\n        }\n\n        currentScanner.truncateToCursor();\n        return columns;\n      }\n\n      if (!this.shouldSkipColumnParse(currentScanner, currentToken, columns)) {\n        const item = this.columnParser.parse(currentScanner);\n\n        if (item === null) {\n          return null;\n        }\n\n        columns.push(item);\n      }\n\n      currentToken = currentScanner.nextNonSpaceToken;\n    }\n\n    if (!hasMoreData) {\n      currentScanner.truncateToCursor();\n      return columns;\n    }\n\n    return null;\n  }\n\n  getStartToken(scanner, columns) {\n    const currentToken = scanner.nextNonSpaceToken;\n\n    if (currentToken !== null && isTokenDelimiter(currentToken, this.parserOptions)) {\n      columns.push('');\n      return scanner.nextNonSpaceToken;\n    }\n\n    return currentToken;\n  }\n\n  shouldSkipColumnParse(scanner, currentToken, columns) {\n    const {\n      parserOptions\n    } = this;\n\n    if (isTokenDelimiter(currentToken, parserOptions)) {\n      scanner.advancePastToken(currentToken); // if the delimiter is at the end of a line\n\n      const nextToken = scanner.nextCharacterToken;\n\n      if (!scanner.hasMoreCharacters || nextToken !== null && isTokenRowDelimiter(nextToken)) {\n        columns.push('');\n        return true;\n      }\n\n      if (nextToken !== null && isTokenDelimiter(nextToken, parserOptions)) {\n        columns.push('');\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nexports.RowParser = RowParser;","map":{"version":3,"sources":["../../../src/parser/RowParser.ts"],"names":[],"mappings":";;;;;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAGA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,MAAM;AAAE,EAAA,mBAAF;AAAuB,EAAA,qBAAvB;AAA8C,EAAA;AAA9C,IAAmE,OAAA,CAAA,KAAzE;;AAEA,MAAa,SAAb,CAAsB;AAKlB,EAAA,WAAA,CAAmB,aAAnB,EAA+C;AAC3C,SAAK,aAAL,GAAqB,aAArB;AACA,SAAK,YAAL,GAAoB,IAAI,QAAA,CAAA,YAAJ,CAAiB,aAAjB,CAApB;AACH;;AAEM,EAAA,KAAK,CAAC,OAAD,EAAiB;AACzB,UAAM;AAAE,MAAA;AAAF,QAAoB,IAA1B;AACA,UAAM;AAAE,MAAA;AAAF,QAAkB,OAAxB;AACA,UAAM,cAAc,GAAG,OAAvB;AACA,UAAM,OAAO,GAAa,EAA1B;AACA,QAAI,YAAY,GAAG,KAAK,aAAL,CAAmB,cAAnB,EAAmC,OAAnC,CAAnB;;AACA,WAAO,YAAP,EAAqB;AACjB,UAAI,mBAAmB,CAAC,YAAD,CAAvB,EAAuC;AACnC,QAAA,cAAc,CAAC,gBAAf,CAAgC,YAAhC,EADmC,CAEnC;AACA;;AACA,YACI,CAAC,cAAc,CAAC,iBAAhB,IACA,qBAAqB,CAAC,YAAD,EAAe,aAAf,CADrB,IAEA,WAHJ,EAIE;AACE,iBAAO,IAAP;AACH;;AACD,QAAA,cAAc,CAAC,gBAAf;AACA,eAAO,OAAP;AACH;;AACD,UAAI,CAAC,KAAK,qBAAL,CAA2B,cAA3B,EAA2C,YAA3C,EAAyD,OAAzD,CAAL,EAAwE;AACpE,cAAM,IAAI,GAAG,KAAK,YAAL,CAAkB,KAAlB,CAAwB,cAAxB,CAAb;;AACA,YAAI,IAAI,KAAK,IAAb,EAAmB;AACf,iBAAO,IAAP;AACH;;AACD,QAAA,OAAO,CAAC,IAAR,CAAa,IAAb;AACH;;AACD,MAAA,YAAY,GAAG,cAAc,CAAC,iBAA9B;AACH;;AACD,QAAI,CAAC,WAAL,EAAkB;AACd,MAAA,cAAc,CAAC,gBAAf;AACA,aAAO,OAAP;AACH;;AACD,WAAO,IAAP;AACH;;AAEO,EAAA,aAAa,CAAC,OAAD,EAAmB,OAAnB,EAAoC;AACrD,UAAM,YAAY,GAAG,OAAO,CAAC,iBAA7B;;AACA,QAAI,YAAY,KAAK,IAAjB,IAAyB,gBAAgB,CAAC,YAAD,EAAe,KAAK,aAApB,CAA7C,EAAiF;AAC7E,MAAA,OAAO,CAAC,IAAR,CAAa,EAAb;AACA,aAAO,OAAO,CAAC,iBAAf;AACH;;AACD,WAAO,YAAP;AACH;;AAEO,EAAA,qBAAqB,CAAC,OAAD,EAAmB,YAAnB,EAAwC,OAAxC,EAAyD;AAClF,UAAM;AAAE,MAAA;AAAF,QAAoB,IAA1B;;AACA,QAAI,gBAAgB,CAAC,YAAD,EAAe,aAAf,CAApB,EAAmD;AAC/C,MAAA,OAAO,CAAC,gBAAR,CAAyB,YAAzB,EAD+C,CAE/C;;AACA,YAAM,SAAS,GAAG,OAAO,CAAC,kBAA1B;;AACA,UAAI,CAAC,OAAO,CAAC,iBAAT,IAA+B,SAAS,KAAK,IAAd,IAAsB,mBAAmB,CAAC,SAAD,CAA5E,EAA0F;AACtF,QAAA,OAAO,CAAC,IAAR,CAAa,EAAb;AACA,eAAO,IAAP;AACH;;AACD,UAAI,SAAS,KAAK,IAAd,IAAsB,gBAAgB,CAAC,SAAD,EAAY,aAAZ,CAA1C,EAAsE;AAClE,QAAA,OAAO,CAAC,IAAR,CAAa,EAAb;AACA,eAAO,IAAP;AACH;AACJ;;AACD,WAAO,KAAP;AACH;;AAxEiB;;AAAtB,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst column_1 = require(\"./column\");\nconst Token_1 = require(\"./Token\");\nconst { isTokenRowDelimiter, isTokenCarriageReturn, isTokenDelimiter } = Token_1.Token;\nclass RowParser {\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.columnParser = new column_1.ColumnParser(parserOptions);\n    }\n    parse(scanner) {\n        const { parserOptions } = this;\n        const { hasMoreData } = scanner;\n        const currentScanner = scanner;\n        const columns = [];\n        let currentToken = this.getStartToken(currentScanner, columns);\n        while (currentToken) {\n            if (isTokenRowDelimiter(currentToken)) {\n                currentScanner.advancePastToken(currentToken);\n                // if ends with CR and there is more data, keep unparsed due to possible\n                // coming LF in CRLF\n                if (!currentScanner.hasMoreCharacters &&\n                    isTokenCarriageReturn(currentToken, parserOptions) &&\n                    hasMoreData) {\n                    return null;\n                }\n                currentScanner.truncateToCursor();\n                return columns;\n            }\n            if (!this.shouldSkipColumnParse(currentScanner, currentToken, columns)) {\n                const item = this.columnParser.parse(currentScanner);\n                if (item === null) {\n                    return null;\n                }\n                columns.push(item);\n            }\n            currentToken = currentScanner.nextNonSpaceToken;\n        }\n        if (!hasMoreData) {\n            currentScanner.truncateToCursor();\n            return columns;\n        }\n        return null;\n    }\n    getStartToken(scanner, columns) {\n        const currentToken = scanner.nextNonSpaceToken;\n        if (currentToken !== null && isTokenDelimiter(currentToken, this.parserOptions)) {\n            columns.push('');\n            return scanner.nextNonSpaceToken;\n        }\n        return currentToken;\n    }\n    shouldSkipColumnParse(scanner, currentToken, columns) {\n        const { parserOptions } = this;\n        if (isTokenDelimiter(currentToken, parserOptions)) {\n            scanner.advancePastToken(currentToken);\n            // if the delimiter is at the end of a line\n            const nextToken = scanner.nextCharacterToken;\n            if (!scanner.hasMoreCharacters || (nextToken !== null && isTokenRowDelimiter(nextToken))) {\n                columns.push('');\n                return true;\n            }\n            if (nextToken !== null && isTokenDelimiter(nextToken, parserOptions)) {\n                columns.push('');\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.RowParser = RowParser;\n//# sourceMappingURL=RowParser.js.map"]},"metadata":{},"sourceType":"script"}